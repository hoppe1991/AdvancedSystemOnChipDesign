% !TEX root = fce.tex
% -----------------------------------------------------------------
% Filename  :	task4.tex
% Author    :	Carsten Hoppe
% Date		:	30. January 2017
% -----------------------------------------------------------------



\subsection{Introduction to the MIPS Enhancements}
\label{sec:introductionToEnhancements}

The aim of this exercise was to add multiple functionalities to a given CPU called „MIPS“. In the beginning there was no pipelining activated and several adjustments had to be maid. In this chapter each of the enhancements are introduced in principle and afterwards its concrete implementation is explained in detail.

For each enhancement a corresponding assemble instruction file was adapted and its execution was carefully observed. Only one enhancement at a time was changed at a time to reduce the space of errors that need to be handled at once.


\subsubsection{Activating Pipelining}
\label{sec:activatingPipelining}
The first wanted improvement of the mips was the activation of pipelining. The following adjustments were made:

Exercise 3-3.3 gave a hint about the writing of data back into a register at a negative clock edge ``The register file must be read in decode stage and written in write back stage within a single cycle.'' TODO Footnote

\lstinputlisting[caption={Change1\_WBatFallingEdge.txt}]{appendix/task3_change1_WBatFallingEdge.txt}

Afterwards conveniently predefined registers which could save and pass on memory instructions at each phase of the pipeline could be inserted by changing the code belonging to each of the registers at the ID (Instruction / Decode) phase, at the EX (Execution) phase, the MA (Memory Access) phase, as well as the WB (Write Back) phase.

\lstinputlisting[caption={Change2\_activatingPipelineRegisters.txt}]{appendix/task3_change2_activatingPipelineRegs.txt}

In order to make sure that no mistakes occured and all steps were taken according to the modification plan precise testing had to take place. Small simple programs were executed and examined using GTKWAVE, a visualization tool for vhdl code executions. First, an assembler program which was perfectly executed by the mips before the adaptions was modified with additional nop commands after each execution command in the code. In fact we needed exactly three nop commands because we were using a 4 stage pipeline and the longest number of clock cycles that one command needed to wait was three clock cycles at this point. The reason is we wanted to mitigate data and control hazards and needed to make sure that the registers were running as expected without taking care of the issues of forwarding and stalling yet. 

Of course it was not the aim to add three nop operations after each instruction every time. But in the beginning this was the approach needed. Later on the goal was to let the mips add nops wherever needed automatically by sending a stalling signal.

\subsubsection{Installing Forwarding}
\label{sec:installingForwarding}

After making sure that pipelining was running the next step at hand was to install a forwarding logic which implements the following behaviour:
\cacheResultFigure{pictures/task3_lectureDescriptionOfForwarding}{FEC Slides, Diagram of Forwading Logic}{fig:picTask3_1}
\lstinputlisting[caption={Change3\_hazardDetectionForwardLogic.txt}]{appendix/task3_change3_hazardDetectionForwardLogic.txt}

The aim was to let instructions that were using registers that were written to in one instruction step earlier use the calculated information directly out of the ALU instead of having to wait until the calculation was written back into a register at WB phase.
The same procedure applies to instructions that needed a calculated result 2 or 3 cock cycles later.
 
\subsubsection{Implementing Stalling}
\label{sec:implementingStalling}

We needed to implement the functionality of the processor to „freeze“ certain processing steps. If an access of a cache or a command like „load word“ takes more than one clock cycle then consequent instructions needed to wait for the corresponding time delay. 
Our implementation basically uses a new signal called „“TODO Insert StallingSignal name which is to be called whenever such a delay occurs. It has three consequences:
\begin{itemize} 
	\item The PC (Program Counter) is kept the same.
	\item The instruction registers in EX phase are overwritten with a nop command. This nop will be passed on to next instruction registers like MA and WB.
	\item The Stalling signal will remain activated until the command which called the Stalling signal reaches the EX, MA, or WB phase. The phase in which the signal is deactivated again depends on the command. Load word for instance only needs a delay of one stalling command. Whereas other commands like conditional branches where the result of the instruction has an impact on the stalling time need more cycles.
\end{itemize}

Testing the functionalities TODO

\subsection{Activating BRAM}
\label{sec:activatingBRAM}

Using BRAM instead or DRAM  TODO check plz resulted in a  
	
4 Nops instead of 3

PC needs to be read of before ID phase

Stalling needed to be adapted.

